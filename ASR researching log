Log 1:
Since our project, ASR, is focused on the construction of the highly functional, stable and adaptable rocket, we need to build a reliable and flexible electronic control system for the rocket in order to realize or solve the different demand in the various situations, which involve the design of both the hardware and software. Due to the fact that I have three years’ experience in the computer programming, I was chosen to be the head designer of the electronic systems, who is responsible of the whole process from the testing hardware to the operation of the system at the final launching. To design such a system is not a very easy task due to the fact that we have to make the system work stably with the high acceleration and severe vibration, which is common during the process of the rocket launching. Also, I have faced a problem that we need to base on the embedded electronic system, which means that we need to program and perform on the chips which have nothing on them-----since they are only the raw chip without the base operational system-------and we need to make the whole organization of the communication between the different chips. After the study of the MCU, the microcontroller chip, I decided to start the research with the Arduino board which contains AVR series microcontroller. This chip has its own IDE and mostly its programming language is adapted from the common C/C++, which is very easy to learn for the c-programming-familiar-beginners like us. Although everybody said so, I feel a little confused with this since I am not very familiar with the electronics, embarrassedly, and the chip-based-programming is so different from the computer-system-based-programming. In order to solve these difficulties, I read some books about the microcontroller and mechanism of the chips and electronics. Most of the time, I was searching on the internet for the information. Luckily, people are glad to share their experience of “making friend with” the microcontroller and the other chips. I am very appreciated of the all the help they offered, especially the people on the Arduino forum and STM forum. More specially, the process of learning how to operate the microcontroller is the process of getting familiar with the how to operate the different ports to communicate and transmit the data by using changing electric voltage. This is also the most different part between the computer-based-programming and chip-based-programming. In the computer-based-programming, the convey of the data or the order is as simple as one line of code, but in the chip, everything become hard to do. For example, the most commonly used input and output port is IO port, which could input or output the high or the low voltage, like the binary switch, just on and off. In order to get information from this IO port, we not only need to give the microcontroller the order “Input the data!”, we also need to make the hardware run step by step. For instance, we need to first start the clock for the port, which gives the heart beats to the port, and we need to set up the definition of what is the IO port and how to be a good IO port---just like tell the baby what is the human. After so many steps of setting, the microcontroller could finally use the IO port. What a silly chip, I thought. But when I got deep in the learning of the MCU, I began to notice that such complicated setting before the using will give the whole MCU, even the whole programmable system, the unbelievable flexibility. For instance, we can give an IO port another parameter or even rebuild an IO port to adapt the requirement of the some extreme tasks. This makes me think about whether the construction of the organization of the programming, even all the kinds of the engineering, is better or more efficient to be built “from the bottom to the top”-----which means the higher level of organization will wrap and concise the lower level of organization. That is quite an interesting question. 















Log 2:
After getting familiar with what I have to use, I start to think about what I do for. Like what I said in the previous log, to build the reliable rocket system is not only the problem of the reliable hardware construction, it mostly depends on the reliability of the software system, which is the soul of the entire system. At first, we low estimated the importance of such thing, thought that this is not a very serious problem. Like always, things didn’t appear like what we thought. The more function that we added to the system, the more complicated the system became, which lead to the appearance of the unpredictable errors. I realize that to cut the functional part of the system is not a preferable choice, so I need to reorganize the structure and the process of the system working. I worked for one whole night to get a self-testing scheme. In this scheme, I make two control systems that are placed in the different positions, the ground station system and the rocket control system, and I let them to do a series of verifying of each other. Since both the system are made by us, so we should consider both of them as the unreliable systems before the testing, which invisibly increase the difficulties of the testing. Suffering from the thousands times of failing and debugging, I finally understand one truth: never believe your system is stable before the system is tested by you, no matter how good and reliable the chip seems to be. This truth is also related to the dilemma I talked about: the chip is more functional means that includes the more complexity----maybe the chip is stable in some settings but the chip will be as crazy as the mad man after changing a little parameter by our carelessly action. So, killing all the undesirable bugs in the program is not an option while what we need to do is to give the system a way to handle the every possible situation and mistakes. For instance, we need to locate our rocket in order to find it after it has landed. We design several ways to achieve such aim: the GPS locating, the radio direction finding and smoke sign marking. Each one has its own merits, like the GPS can offer the precise and real-time location data while the radio direction finding is much more reliable. Anyone of these methods can lead us to get the exact location that the rocket is, but also anyone of these methods can be dysfunctional. So what I did is to combine all of them and make sure that there is at least one way to find the rocket. However, in the other parts of the system, the combination of the different methods will not give the result that we want but it will cause the components to contradict with each other and lower the succession rate. For instance, the control of the opening of the parachute also has various ways to decide when to give the signal of opening. For instance, I used to think use the attitude calculation to get the real-time acceleration and velocity in the ground coordinate system, which shows us when the rocket has reached its highest point---when the velocity is zero-----and ready for the opening of the parachute. But the precision and the reliability of this method are severely depending on the precision of the sensor we used and the performance of the offset algorithm we add in the attitude calculation. More detailed speaking, the not good enough sensors will give the data varied in a large range even they are placed in the rest place. Being constricted by the limit budget, we could only afford the relatively lower performance sensors. The offset algorithm I wrote is not capable enough of fixing such error. All of the above will make the calculation become much more unpredictable. In the worst case, the wrongly calculated time will cause our rocket to open its parachute when its engine is still working, which will cause the parachute immediately to be tangled and torn by the rocket main body. (An important note: such result will only be occurred when we put the parachute in the head of the rocket. I have designed the different plan---like open the parachute from the bottom of the rocket----which I will write more details in the following logs.) In the other hand, we can use the timing method to open the parachute, the triggering time of time which is fixed in the program. This method is much more reliable than the previous one if the triggering time we calculated is precise enough. This method is so “honest” that it will not change a single bit by itself in different situation. We are worried about whether we could give an acceptable time only with the thrust data of the rocket engine working test and the ideal aerodynamics simulation. I once have thought about combine two of them in a way of calculating the function of the reliability of each method in different periods. For example, the acceleration sensor becomes much more unreliable as the rocket is going up since the vibration which mostly influences the reliability of the acceleration sensor becomes much more intense when the engine is keep working and accelerating. So I give the acceleration sensor a decreasing reliability function as time is going up until the engine is stop working. And since the triggering time that worked out by our self is fixed and will not be affected by the time, it has one constant reliability value. Therefore, we could use the product or other mathematics result of these reliability functions and their real-time data as one parameter in our triggering procedure. This sounds to be a good plan, but the reliability functions are not as ideal as I thought, or even there is no kind of such function that we use to evaluate the result of the different unreliable data producers. (This drives me to read and learn about the DPPX---the distributed processing---which also face the problem of how to get a united result from the system that contains different processors that has a possibility to be broken. The mathematicians have proved that there is no way to give a perfect way to solve this problem while in order to give an approximating result, we need to bear some extents of mistakes to be constantly existed in the systems. That’s very enlightening and maybe in the future we can use such kind of ideas to solve the complicated sensor systems.) As a result, we give up all the complex plans and choose the fixed time triggering as the final plan. We got the information that the other armature rocket making groups abroad mostly used the fixed time triggering. This may have taught us a lesson: maybe sometimes the silly-looked-plans may have the higher value.
